#include <SerialBT.h>
#include <TOTP.h>

#include <functional>
#include <iostream>
#include <vector>

#include "Arduino.h"
#include "Interval.cpp"
#include "Network.hpp"
#include "Player.hpp"
#include "Servo.hpp"
#include "Sleep.cpp"
#include "hardware/clocks.h"
#include "hardware/gpio.h"
#include "hardware/pwm.h"
#include "pico/binary_info.h"
#include "pico/multicore.h"
#include "pico/stdlib.h"

#define API_OPEN_KEEP_SECONDS 60
#define MANUAL_OPEN_KEEP_SECONDS 60
#define PIN_GREEN 0
#define PIN_RED 1
#define PIN_SERVO 28
#define PIN_BUTTON_OUT 2
#define PIN_BUTTON_IN 3
#define PIN_BUZZER 4
#define NOW secondsDiff + current_seconds()
#define TOTP_TOKEN totp.getCode(NOW)
#define API_CHECK_INTERVAL 3
#define INTERVAL_LOCK_INTERVAL 600

#define PLAY_OPEN_TAG "PLAY_OPEN"
#define PLAY_CLOSE_TAG "PLAY_CLOSE"
#define API_CHECK_TAG "API_CHECK"
#define LOCK_TAG "LOCK_TAG"
#define INTERVAL_LOCK_TAG "INTERVAL_LOCK_TAG"

int secondsDiff;

auto_init_mutex(task_mutex);
auto_init_mutex(operation_mutex);
auto_init_mutex(api_mutex);

bool tryLock(mutex_t &mutex) {
  uint32_t owner_out;
  return mutex_try_enter(&mutex, &owner_out);
}

void waitLock(mutex_t &mutex) {
  uint32_t owner_out;
  while (true) {
    if (mutex_try_enter(&mutex, &owner_out)) break;
    sleep_ms(10);
  }
}
void releaseLock(mutex_t &mutex) {
  mutex_exit(&mutex);
}

void init_io() {
  gpio_init(PIN_RED);
  gpio_set_dir(PIN_RED, GPIO_OUT);

  gpio_init(PIN_GREEN);
  gpio_set_dir(PIN_GREEN, GPIO_OUT);

  gpio_init(PIN_BUTTON_IN);
  gpio_set_dir(PIN_BUTTON_IN, GPIO_IN);
  gpio_pull_down(PIN_BUTTON_IN);

  gpio_init(PIN_BUTTON_OUT);
  gpio_set_dir(PIN_BUTTON_OUT, GPIO_OUT);
  gpio_put(PIN_BUTTON_OUT, 1);

  gpio_init(PIN_SERVO);
  gpio_set_function(PIN_SERVO, GPIO_FUNC_PWM);
}

struct Color {
  bool red;
  bool green;

  void set() const {
    gpio_put(PIN_RED, red);
    gpio_put(PIN_GREEN, green);
  }
};

Servo servo = Servo(PIN_SERVO);
Player player = Player(PIN_BUZZER);

class LockState {
public:
  static const uint DIG_CLOSE = 180;
  static const uint DIG_NEUTRAL = 90;
  static const uint DIG_OPEN = 0;

  double value;
  Color color;

  LockState(double val, const Color &c)
    : value(val), color(c) {}

  void operate() const {
    servo.rotate(value);
    sleep_ms(750);
  }
  void operateWithoutWait() const {
    servo.rotate(value);
  }

  void setColor() const {
    color.set();
  }

  bool operator==(const LockState &other) const {
    return value == other.value;
  }

  static const LockState CLOSE;
  static const LockState NEUTRAL;
  static const LockState OPEN;
};

const Color RED_COLOR = { true, false };
const Color GREEN_COLOR = { false, true };
const Color YELLOW_COLOR = { true, true };

const LockState LockState::CLOSE(LockState::DIG_CLOSE, GREEN_COLOR);
const LockState LockState::NEUTRAL(LockState::DIG_NEUTRAL, YELLOW_COLOR);
const LockState LockState::OPEN(LockState::DIG_OPEN, RED_COLOR);

const int c4 = 262;
const int cs4 = 277;
const int d4 = 294;
const int ds4 = 311;
const int e4 = 330;
const int f4 = 349;
const int fs4 = 370;
const int g4 = 392;
const int gs4 = 415;
const int a4 = 440;
const int as4 = 466;
const int b4 = 494;
const int c5 = 523;
const int cs5 = 554;
const int d5 = 587;
const int space = 0;

// c4, c4, g4, g4, a4, a4, g4, space,
//     f4, f4, e4, e4, d4, d4, c4, space,

std::vector<Sound> open;
std::vector<Sound> close;

enum class Task {
  PLAY_OPEN,
  PLAY_CLOSE,
  API_CHECK,
  LOCK,
  LOCK_WITHOUT_NOTIFY,
  LOCK_API,
  UNLOCK_API,
};
std::vector<Task> tasks;
void pushTask(Task task);
bool before;
Interval interval = Interval();
LockState currentState = LockState::CLOSE;

uint8_t hmacKey[] = { 0x64, 0x66, 0x66, 0x37, 0x32, 0x35, 0x31, 0x39, 0x66, 0x63, 0x62, 0x36, 0x37, 0x36, 0x39, 0x31, 0x38, 0x36, 0x33, 0x38, 0x31, 0x30, 0x34, 0x65, 0x66, 0x34, 0x65, 0x39, 0x32, 0x37, 0x37, 0x31, 0x62, 0x34, 0x38, 0x34, 0x37, 0x66, 0x61, 0x39, 0x37, 0x63, 0x33, 0x34, 0x31, 0x34, 0x39, 0x34, 0x64, 0x34, 0x31, 0x31, 0x63, 0x35, 0x39, 0x37, 0x30, 0x34, 0x62, 0x62, 0x64, 0x38, 0x32, 0x35, 0x61, 0x31, 0x64, 0x36, 0x61, 0x62, 0x62, 0x32, 0x33, 0x34, 0x33, 0x33, 0x61, 0x34, 0x64, 0x39, 0x62, 0x36, 0x36, 0x65, 0x34, 0x39, 0x66, 0x30, 0x64, 0x63, 0x36, 0x62, 0x38, 0x63, 0x38, 0x35, 0x32, 0x34, 0x35, 0x37, 0x30, 0x35, 0x65, 0x66, 0x61, 0x39, 0x61, 0x36, 0x38, 0x61, 0x66, 0x61, 0x36, 0x62, 0x64, 0x61, 0x34, 0x36, 0x31, 0x63, 0x33, 0x33, 0x33, 0x37, 0x32, 0x38, 0x61, 0x61, 0x64, 0x38, 0x66, 0x36, 0x36, 0x35, 0x64, 0x61, 0x61, 0x32, 0x37, 0x37, 0x63, 0x34, 0x64, 0x36, 0x38, 0x32, 0x36, 0x61, 0x31, 0x66, 0x62, 0x36, 0x62, 0x34, 0x35, 0x65, 0x33, 0x30, 0x65, 0x65, 0x31, 0x36, 0x39, 0x32, 0x39, 0x64, 0x65, 0x34, 0x32, 0x31, 0x61, 0x65, 0x36, 0x63, 0x34, 0x32, 0x34, 0x37, 0x30, 0x35, 0x32, 0x31, 0x65, 0x39, 0x36, 0x37, 0x36, 0x39, 0x37, 0x39, 0x63, 0x37, 0x65, 0x34, 0x36, 0x38, 0x65, 0x37, 0x32, 0x36, 0x65, 0x62, 0x31, 0x34, 0x38, 0x37, 0x34, 0x33, 0x31, 0x65, 0x39, 0x61, 0x62, 0x61, 0x36, 0x62, 0x63, 0x38, 0x39, 0x33, 0x36, 0x65, 0x38, 0x33, 0x32, 0x64, 0x38, 0x38, 0x63, 0x66, 0x34, 0x30, 0x35, 0x31, 0x33, 0x34, 0x64, 0x31, 0x37, 0x65, 0x62, 0x35, 0x63, 0x64, 0x62, 0x38, 0x34, 0x39, 0x32, 0x36, 0x65, 0x62, 0x61, 0x31, 0x62, 0x63, 0x38, 0x61, 0x39, 0x36, 0x65, 0x63, 0x37, 0x33, 0x62, 0x34, 0x31, 0x33, 0x64, 0x36, 0x37, 0x64, 0x64, 0x30, 0x66, 0x39, 0x36, 0x31, 0x37, 0x62, 0x31, 0x61, 0x33, 0x66, 0x66, 0x38, 0x38, 0x38, 0x36, 0x61, 0x62, 0x32, 0x64, 0x31, 0x65, 0x36, 0x30, 0x30, 0x31, 0x62, 0x62, 0x35, 0x65, 0x37, 0x62, 0x34, 0x35, 0x37, 0x32, 0x61, 0x64, 0x31, 0x35, 0x66, 0x32, 0x32, 0x62, 0x62, 0x66, 0x30, 0x65, 0x66, 0x64, 0x36, 0x63, 0x30, 0x30, 0x33, 0x65, 0x38, 0x31, 0x65, 0x63, 0x33, 0x63, 0x39, 0x65, 0x36, 0x36, 0x61, 0x63, 0x33, 0x31, 0x32, 0x31, 0x63, 0x31, 0x66, 0x62, 0x34, 0x33, 0x34, 0x39, 0x39, 0x62, 0x65, 0x31, 0x64, 0x37, 0x64, 0x37, 0x38, 0x66, 0x34, 0x32, 0x38, 0x33, 0x34, 0x66, 0x31, 0x33, 0x39, 0x30, 0x61, 0x30, 0x63, 0x38, 0x61, 0x63, 0x30, 0x36, 0x63, 0x39, 0x63, 0x61, 0x32, 0x34, 0x64, 0x61, 0x66, 0x66, 0x36, 0x39, 0x32, 0x35, 0x39, 0x65, 0x64, 0x36, 0x38, 0x65, 0x38, 0x38, 0x35, 0x37, 0x33, 0x63, 0x61, 0x66, 0x62, 0x31, 0x61, 0x36, 0x35, 0x61, 0x31, 0x34, 0x33, 0x61, 0x66, 0x37, 0x30, 0x31, 0x64, 0x30, 0x36, 0x37, 0x64, 0x37, 0x32, 0x33, 0x36, 0x37, 0x62, 0x66, 0x66, 0x61, 0x35, 0x34, 0x62, 0x64, 0x37, 0x35, 0x63, 0x64, 0x36, 0x36, 0x66, 0x37, 0x66, 0x31, 0x61, 0x64, 0x62, 0x66, 0x36, 0x37, 0x37, 0x34, 0x62, 0x30, 0x63, 0x38, 0x62, 0x32, 0x38, 0x39, 0x31, 0x39, 0x36, 0x61, 0x65, 0x61, 0x31, 0x61, 0x34, 0x65, 0x39, 0x63, 0x34, 0x61, 0x37, 0x37, 0x62, 0x34, 0x38, 0x66, 0x33, 0x38, 0x35, 0x34, 0x34, 0x32, 0x33, 0x61, 0x34, 0x61, 0x37, 0x65, 0x37, 0x38, 0x35, 0x65, 0x66, 0x63, 0x33, 0x39, 0x31, 0x66, 0x65, 0x61, 0x63, 0x34, 0x35, 0x32, 0x65, 0x63, 0x63, 0x62, 0x30, 0x64, 0x63, 0x63, 0x36, 0x34, 0x65, 0x32, 0x63, 0x64, 0x31, 0x32, 0x39, 0x34, 0x37, 0x38, 0x36, 0x30, 0x64, 0x32, 0x31, 0x65, 0x39, 0x37, 0x63, 0x62, 0x34, 0x35, 0x33, 0x39, 0x63, 0x64, 0x32, 0x39, 0x61, 0x66, 0x61, 0x39, 0x32, 0x65, 0x65, 0x31, 0x36, 0x32, 0x38, 0x37, 0x63, 0x61, 0x34, 0x39, 0x61, 0x62, 0x37, 0x66, 0x38, 0x30, 0x35, 0x34, 0x62, 0x37, 0x39, 0x62, 0x61, 0x39, 0x34, 0x63, 0x61, 0x66, 0x35, 0x35, 0x66, 0x31, 0x36, 0x33, 0x34, 0x35, 0x61, 0x64, 0x36, 0x63, 0x39, 0x34, 0x36, 0x63, 0x35, 0x39, 0x35, 0x30, 0x34, 0x36, 0x39, 0x35, 0x31, 0x35, 0x64, 0x32, 0x37, 0x35, 0x65, 0x31, 0x38, 0x65, 0x63, 0x32, 0x32, 0x34, 0x30, 0x39, 0x34, 0x33, 0x30, 0x38, 0x63, 0x34, 0x33, 0x61, 0x33, 0x32, 0x33, 0x64, 0x37, 0x30, 0x35, 0x64, 0x30, 0x61, 0x61, 0x39, 0x64, 0x63, 0x33, 0x31, 0x36, 0x61, 0x33, 0x37, 0x65, 0x64, 0x64, 0x30, 0x31, 0x61, 0x65, 0x36, 0x38, 0x64, 0x32, 0x32, 0x64, 0x34, 0x35, 0x61, 0x37, 0x39, 0x39, 0x35, 0x66, 0x65, 0x30, 0x39, 0x36, 0x63, 0x32, 0x63, 0x66, 0x33, 0x38, 0x34, 0x39, 0x34, 0x30, 0x34, 0x30, 0x61, 0x62, 0x64, 0x31, 0x34, 0x39, 0x65, 0x64, 0x30, 0x34, 0x30, 0x32, 0x66, 0x36, 0x66, 0x37, 0x31, 0x31, 0x34, 0x35, 0x38, 0x36, 0x34, 0x36, 0x38, 0x36, 0x34, 0x65, 0x36, 0x36, 0x62, 0x63, 0x36, 0x34, 0x30, 0x65, 0x30, 0x65, 0x30, 0x64, 0x31, 0x30, 0x61, 0x36, 0x36, 0x63, 0x33, 0x64, 0x62, 0x63, 0x66, 0x62, 0x32, 0x64, 0x35, 0x30, 0x31, 0x31, 0x34, 0x66, 0x66, 0x65, 0x39, 0x37, 0x31, 0x64, 0x34, 0x35, 0x38, 0x66, 0x66, 0x66, 0x34, 0x65, 0x66, 0x32, 0x35, 0x63, 0x34, 0x36, 0x39, 0x61, 0x35, 0x63, 0x36, 0x33, 0x36, 0x66, 0x64, 0x61, 0x35, 0x32, 0x34, 0x33, 0x39, 0x30, 0x64, 0x31, 0x37, 0x30, 0x62, 0x62, 0x36, 0x66, 0x32, 0x36, 0x63, 0x64, 0x64, 0x65, 0x31, 0x34, 0x34, 0x32, 0x32, 0x38, 0x63, 0x64, 0x37, 0x30, 0x35, 0x66, 0x39, 0x61, 0x34, 0x65, 0x35, 0x66, 0x38, 0x66, 0x35, 0x38, 0x63, 0x38, 0x66, 0x64, 0x33, 0x32, 0x31, 0x33, 0x39, 0x66, 0x61, 0x64, 0x65, 0x65, 0x61, 0x35, 0x65, 0x36, 0x38, 0x32, 0x37, 0x31, 0x61, 0x63, 0x65, 0x61, 0x66, 0x35, 0x63, 0x30, 0x30, 0x34, 0x30, 0x37, 0x64, 0x61, 0x38, 0x35, 0x66, 0x61, 0x34, 0x62, 0x34, 0x63, 0x65, 0x39, 0x34, 0x63, 0x37, 0x30, 0x32, 0x32, 0x33, 0x64, 0x66, 0x31, 0x37, 0x63, 0x65, 0x35, 0x36, 0x37, 0x61, 0x61, 0x63, 0x35, 0x63, 0x32, 0x36, 0x37, 0x63, 0x31, 0x38, 0x36, 0x65, 0x66, 0x66, 0x62, 0x61, 0x37, 0x33, 0x30, 0x36, 0x31, 0x30, 0x66, 0x66, 0x64, 0x39, 0x64, 0x30, 0x63, 0x62, 0x61, 0x64, 0x66, 0x30, 0x35, 0x63, 0x35, 0x65, 0x63, 0x31, 0x38, 0x37, 0x64, 0x66, 0x62, 0x61, 0x38, 0x30, 0x64, 0x38, 0x38, 0x66, 0x35, 0x30, 0x63, 0x36, 0x32, 0x65, 0x64, 0x39, 0x65, 0x32, 0x37, 0x35, 0x35, 0x39, 0x37, 0x39, 0x38, 0x39, 0x33, 0x37, 0x33, 0x33, 0x61, 0x62, 0x39, 0x66, 0x35, 0x34, 0x34, 0x35, 0x61, 0x65, 0x32, 0x65, 0x36, 0x33, 0x61, 0x64, 0x37, 0x62, 0x37, 0x39, 0x33, 0x64, 0x39, 0x33, 0x65, 0x31, 0x32, 0x39, 0x66, 0x66, 0x32, 0x31, 0x36, 0x62, 0x31, 0x30, 0x39, 0x39, 0x33, 0x38, 0x62, 0x30, 0x66, 0x64, 0x32, 0x31, 0x62, 0x30, 0x36, 0x61, 0x38, 0x37, 0x30, 0x30, 0x35, 0x37, 0x65, 0x63, 0x62, 0x66, 0x65, 0x35, 0x66, 0x62, 0x36, 0x64, 0x63, 0x36, 0x33, 0x33, 0x63, 0x61, 0x31, 0x35, 0x31, 0x38, 0x30, 0x34, 0x30, 0x65, 0x39, 0x39, 0x35, 0x36, 0x36, 0x34, 0x32, 0x36, 0x31, 0x36, 0x36, 0x61, 0x37, 0x61, 0x61, 0x63, 0x32, 0x36, 0x61, 0x38, 0x39, 0x39, 0x35, 0x34, 0x33, 0x37, 0x35, 0x34, 0x62, 0x33, 0x39, 0x30, 0x32, 0x36, 0x31, 0x36, 0x36, 0x64, 0x38, 0x66, 0x35, 0x65, 0x39, 0x62, 0x33, 0x65, 0x35, 0x66, 0x37, 0x66, 0x65, 0x62, 0x62, 0x65, 0x39, 0x63, 0x37, 0x36, 0x64, 0x34, 0x33, 0x31, 0x38, 0x61, 0x33, 0x36, 0x30, 0x38, 0x38, 0x63, 0x62, 0x35, 0x61, 0x34, 0x32, 0x61, 0x34, 0x38, 0x33, 0x66, 0x38, 0x66, 0x30, 0x64, 0x66, 0x38, 0x65, 0x64, 0x34, 0x36, 0x33, 0x30, 0x33, 0x33, 0x66, 0x33, 0x66, 0x37, 0x64, 0x66, 0x32, 0x36, 0x35, 0x31, 0x37, 0x61, 0x30, 0x35, 0x39, 0x65, 0x38, 0x33, 0x38, 0x33, 0x38, 0x36, 0x38, 0x65, 0x61, 0x34, 0x62, 0x63, 0x30, 0x61, 0x37, 0x39, 0x36, 0x39, 0x37, 0x34, 0x65, 0x37, 0x39, 0x31, 0x39, 0x36, 0x33, 0x33, 0x63, 0x31, 0x36, 0x62, 0x38, 0x61, 0x38, 0x30, 0x66, 0x39, 0x65, 0x39, 0x35, 0x32, 0x62, 0x63, 0x30, 0x32, 0x30, 0x62, 0x30, 0x31, 0x36, 0x36, 0x62, 0x62, 0x36, 0x32, 0x30, 0x34, 0x63, 0x62, 0x66, 0x61, 0x66, 0x36, 0x62, 0x36, 0x66, 0x31, 0x32, 0x64, 0x62, 0x62, 0x39, 0x64, 0x35, 0x33, 0x61, 0x31, 0x64, 0x38, 0x63, 0x30, 0x30, 0x38, 0x37, 0x63, 0x36, 0x38, 0x66, 0x35, 0x61, 0x36, 0x65, 0x61, 0x61, 0x34, 0x36, 0x32, 0x34, 0x31, 0x32, 0x34, 0x31, 0x64, 0x39, 0x33, 0x62, 0x36, 0x61, 0x61, 0x63, 0x32, 0x38, 0x65, 0x37, 0x66, 0x37, 0x35, 0x35, 0x66, 0x61, 0x31, 0x38, 0x34, 0x34, 0x39, 0x31, 0x30, 0x64, 0x34, 0x63, 0x31, 0x31, 0x62, 0x63, 0x33, 0x61, 0x36, 0x64, 0x30, 0x34, 0x65, 0x39, 0x66, 0x36, 0x30, 0x33, 0x64, 0x62, 0x38, 0x34, 0x38, 0x65, 0x63, 0x39, 0x65, 0x36, 0x63, 0x65, 0x65, 0x32, 0x62, 0x38, 0x35, 0x36, 0x32, 0x65, 0x33, 0x38, 0x61, 0x39, 0x66, 0x37, 0x39, 0x33, 0x63, 0x66, 0x65, 0x65, 0x36, 0x66, 0x38, 0x30, 0x64, 0x30, 0x64, 0x39, 0x39, 0x36, 0x34, 0x30, 0x37, 0x34, 0x33, 0x36, 0x30, 0x37, 0x32, 0x35, 0x37, 0x36, 0x63, 0x34, 0x30, 0x31, 0x33, 0x65, 0x61, 0x63, 0x34, 0x65, 0x34, 0x37, 0x66, 0x61, 0x32, 0x36, 0x31, 0x33, 0x64, 0x34, 0x31, 0x32, 0x38, 0x65, 0x37, 0x66, 0x63, 0x36, 0x65, 0x37, 0x61, 0x38, 0x32, 0x30, 0x38, 0x39, 0x31, 0x30, 0x62, 0x64, 0x38, 0x32, 0x34, 0x37, 0x30, 0x33, 0x33, 0x61, 0x39, 0x34, 0x62, 0x62, 0x30, 0x66, 0x38, 0x65, 0x35, 0x62, 0x31, 0x64, 0x39, 0x33, 0x34, 0x65, 0x33, 0x65, 0x36, 0x31, 0x31, 0x65, 0x66, 0x62, 0x62, 0x64, 0x35, 0x61, 0x30, 0x31, 0x34, 0x36, 0x33, 0x64, 0x61, 0x30, 0x36, 0x33, 0x36, 0x66, 0x61, 0x66, 0x64, 0x35, 0x66, 0x61, 0x31, 0x30, 0x61, 0x32, 0x32, 0x35, 0x36, 0x34, 0x65, 0x35, 0x64, 0x35, 0x38, 0x32, 0x31, 0x65, 0x36, 0x31, 0x34, 0x38, 0x66, 0x36, 0x62, 0x62, 0x37, 0x65, 0x31, 0x32, 0x33, 0x39, 0x35, 0x30, 0x61, 0x33, 0x39, 0x63, 0x35, 0x63, 0x31, 0x35, 0x61, 0x62, 0x36, 0x37, 0x65, 0x65, 0x61, 0x31, 0x33, 0x39, 0x32, 0x61, 0x37, 0x30, 0x31, 0x32, 0x32, 0x32, 0x66, 0x63, 0x63, 0x39, 0x63, 0x62, 0x62, 0x65, 0x39, 0x61, 0x36, 0x39, 0x39, 0x64, 0x31, 0x34, 0x64, 0x33, 0x66, 0x37, 0x64, 0x61, 0x34, 0x32, 0x35, 0x35, 0x37, 0x37, 0x36, 0x62, 0x33, 0x35, 0x63, 0x34, 0x63, 0x37, 0x61, 0x61, 0x38, 0x33, 0x31, 0x30, 0x61, 0x66, 0x62, 0x38, 0x37, 0x32, 0x38, 0x30, 0x62, 0x63, 0x31, 0x64, 0x38, 0x61, 0x34, 0x62, 0x33, 0x61, 0x33, 0x64, 0x34, 0x34, 0x64, 0x31, 0x34, 0x39, 0x37, 0x38, 0x65, 0x39, 0x32, 0x36, 0x30, 0x37, 0x39, 0x66, 0x37, 0x32, 0x35, 0x62, 0x63, 0x33, 0x35, 0x34, 0x63, 0x35, 0x35, 0x66, 0x34, 0x65, 0x31, 0x31, 0x66, 0x37, 0x64, 0x61, 0x31, 0x32, 0x36, 0x65, 0x31, 0x62, 0x30, 0x31, 0x66, 0x64, 0x39, 0x31, 0x62, 0x62, 0x36, 0x33, 0x37, 0x66, 0x61, 0x30, 0x34, 0x38, 0x34, 0x35, 0x37, 0x36, 0x65, 0x62, 0x34, 0x35, 0x32, 0x38, 0x31, 0x33, 0x37, 0x66, 0x31, 0x64, 0x36, 0x39, 0x32, 0x65, 0x39, 0x34, 0x30, 0x30, 0x65, 0x31, 0x34, 0x61, 0x37, 0x30, 0x65, 0x36, 0x63, 0x36, 0x38, 0x39, 0x31, 0x35, 0x30, 0x64, 0x61, 0x31, 0x63, 0x30, 0x37, 0x36, 0x39, 0x35, 0x34, 0x37, 0x32, 0x33, 0x65, 0x33, 0x63, 0x64, 0x65, 0x63, 0x63, 0x65, 0x37, 0x30, 0x33, 0x32, 0x35, 0x37, 0x63, 0x34, 0x38, 0x33, 0x35, 0x32, 0x35, 0x31, 0x33, 0x30, 0x36, 0x61, 0x61, 0x36, 0x34, 0x66, 0x30, 0x63, 0x65, 0x30, 0x34, 0x64, 0x65, 0x62, 0x38, 0x63, 0x65, 0x66, 0x64, 0x35, 0x66, 0x61, 0x30, 0x37, 0x65, 0x31, 0x65, 0x33, 0x64, 0x32, 0x38, 0x66, 0x36, 0x33, 0x32, 0x62, 0x35, 0x34, 0x64, 0x65, 0x38, 0x65, 0x36, 0x66, 0x66, 0x34, 0x66, 0x39, 0x64, 0x65, 0x32, 0x39, 0x33, 0x35, 0x36, 0x66, 0x30, 0x35, 0x31, 0x34, 0x30, 0x64, 0x38, 0x61, 0x63, 0x35, 0x31, 0x62, 0x36, 0x63, 0x37, 0x38, 0x38, 0x37, 0x66, 0x33, 0x34, 0x64, 0x31, 0x61, 0x34, 0x39, 0x64, 0x38, 0x31, 0x35, 0x61, 0x39, 0x35, 0x31, 0x63, 0x63, 0x66, 0x31, 0x37, 0x38, 0x33, 0x63, 0x33, 0x31, 0x32, 0x35, 0x33, 0x63, 0x39, 0x64, 0x35, 0x30, 0x35, 0x32, 0x31, 0x61, 0x33, 0x34, 0x35, 0x64, 0x62, 0x65, 0x35, 0x30, 0x33, 0x36, 0x32, 0x34, 0x39, 0x36, 0x37, 0x66, 0x61, 0x64, 0x37, 0x65, 0x66, 0x61, 0x31, 0x36, 0x37, 0x35, 0x63, 0x33, 0x32, 0x63, 0x38, 0x34, 0x37, 0x62, 0x62, 0x66, 0x35, 0x63, 0x66, 0x34, 0x62, 0x63, 0x35, 0x39, 0x30, 0x33, 0x33, 0x34, 0x61, 0x62, 0x61, 0x33, 0x32, 0x62, 0x64, 0x36, 0x39, 0x33, 0x65, 0x34, 0x64, 0x63, 0x34, 0x33, 0x66, 0x65, 0x66, 0x38, 0x63, 0x39, 0x66, 0x34, 0x39, 0x36, 0x36, 0x61, 0x38, 0x61, 0x31, 0x33, 0x36, 0x66, 0x34, 0x64, 0x37, 0x39, 0x64, 0x32, 0x63, 0x64, 0x39, 0x62, 0x37, 0x62, 0x34, 0x38, 0x64, 0x36, 0x38, 0x30, 0x66, 0x36, 0x37, 0x31, 0x33, 0x32, 0x63, 0x31, 0x33, 0x36, 0x63, 0x35, 0x33, 0x37, 0x39, 0x66, 0x33, 0x33, 0x34, 0x30, 0x33, 0x39, 0x35, 0x62, 0x34, 0x33, 0x30, 0x62, 0x37, 0x31, 0x32, 0x38, 0x32, 0x37, 0x31, 0x32, 0x30, 0x38, 0x39, 0x31, 0x65, 0x39, 0x32, 0x38, 0x62, 0x36, 0x31, 0x39, 0x63, 0x63, 0x64, 0x66, 0x38, 0x31, 0x36, 0x65, 0x61, 0x64, 0x34, 0x35, 0x64, 0x63, 0x33, 0x37, 0x31, 0x32, 0x39, 0x61, 0x65, 0x39, 0x31, 0x35, 0x39, 0x33, 0x32, 0x62, 0x33, 0x39, 0x64, 0x39, 0x61, 0x39, 0x33, 0x65, 0x62, 0x63, 0x36, 0x39, 0x30, 0x65, 0x31, 0x65, 0x66, 0x36, 0x33, 0x36, 0x37, 0x38, 0x63, 0x65, 0x34, 0x32, 0x65, 0x34, 0x36, 0x32, 0x61, 0x36, 0x33, 0x32, 0x30, 0x30, 0x33, 0x62, 0x39, 0x61, 0x61, 0x62, 0x37, 0x64, 0x35, 0x36, 0x30, 0x35, 0x38, 0x38, 0x66, 0x64, 0x66, 0x37, 0x31, 0x39, 0x35, 0x32, 0x61, 0x63 };

TOTP totp = TOTP(hmacKey, 2048);

void checkAPI();
void waitTask() {
  while (true) {
    waitLock(task_mutex);
    try {
      if (tasks.size() > 0) {
        Task task = tasks[0];
        tasks.erase(tasks.begin());

        releaseLock(task_mutex);
        if (task == Task::PLAY_OPEN) {
          player.play(open);
        } else if (task == Task::PLAY_CLOSE) {
          player.play(close);
        } else if (task == Task::API_CHECK) {
          checkAPI();
        } else if (task == Task::LOCK) {
          currentState = LockState::CLOSE;
          tasks.push_back(Task::LOCK_API);
          operate();
        } else if (task == Task::LOCK_WITHOUT_NOTIFY) {
          currentState = LockState::CLOSE;
          tasks.push_back(Task::LOCK_API);
          operate_without_notify();
        } else if (task == Task::LOCK_API) {
          waitLock(api_mutex);
          lockAPI(TOTP_TOKEN);
          releaseLock(api_mutex);
        } else if (task == Task::UNLOCK_API) {
          waitLock(api_mutex);
          unlockAPI(TOTP_TOKEN);
          releaseLock(api_mutex);
        }
      } else {
        releaseLock(task_mutex);
      }
    } catch (...) {
      releaseLock(api_mutex);
    }
    sleep_ms(100);
  }
}

void pushTask(Task task) {
  waitLock(task_mutex);
  tasks.push_back(task);
  releaseLock(task_mutex);
}

int current_seconds() {
  return std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
}

void operate() {
  SerialBT.printf("[operate][%d] start. currentState: %s\n", NOW, currentState == LockState::OPEN ? "OPEN" : "CLOSE");
  if (!tryLock(operation_mutex)) return;

  if (currentState == LockState::OPEN) {
    pushTask(Task::PLAY_OPEN);
  } else {
    pushTask(Task::PLAY_CLOSE);
  }
  LockState::NEUTRAL.setColor();
  currentState.operate();
  currentState.setColor();
  LockState::NEUTRAL.operateWithoutWait();

  releaseLock(operation_mutex);
  SerialBT.printf("[operate][%d] done\n", NOW);
}

void operate_without_notify() {
  SerialBT.printf("[operate_without_notify][%d] start. currentState: %s\n", NOW, currentState == LockState::OPEN ? "OPEN" : "CLOSE");
  if (!tryLock(operation_mutex)) return;

  LockState::NEUTRAL.setColor();
  currentState.operate();
  currentState.setColor();
  LockState::NEUTRAL.operateWithoutWait();

  releaseLock(operation_mutex);
  SerialBT.printf("[operate_without_notify][%d] done\n", NOW);
}

void checkAPI() {
  SerialBT.printf("[checkAPI][%d] start checkAPI\n", NOW);
  if (!tryLock(api_mutex)) return;
  APILockState currentLockState = getState(TOTP_TOKEN);

  switch (currentLockState) {
    case APILockState::LOCKED:
      if (currentState == LockState::OPEN) {
        SerialBT.printf("[checkAPI][%d] CLOSING\n", NOW);
        currentState = LockState::CLOSE;
        interval.eraseByTag(LOCK_TAG);
        operate();
      }
      break;
    case APILockState::UNLOCKED:
      if (currentState == LockState::CLOSE) {
        SerialBT.printf("[checkAPI][%d] UNLOCKING\n", NOW);
        currentState = LockState::OPEN;
        operate();

        interval.setTimeout(
          API_OPEN_KEEP_SECONDS * 1000, []() {
            tasks.push_back(Task::LOCK);
          },
          LOCK_TAG);
      }
      break;
  }
  releaseLock(api_mutex);
  SerialBT.printf("[checkAPI][%d] end checkAPI\n", NOW);
}

void setup() {
  init_io();

  LockState::NEUTRAL.setColor();

  SerialBT.begin();
  connect_wifi();

  secondsDiff = get_timestamp() - current_seconds();

  for (int freq : (std::vector<int>){ d4, g4, f4, d5 }) {
    open.push_back(Sound(freq, 150));
    open.push_back(Sound(space, 50));
  }
  open.end()[-2].duration = 250;
  for (int freq : (std::vector<int>){ d5, c5, g4, b4 }) {
    close.push_back(Sound(freq, 150));
    close.push_back(Sound(space, 50));
  }
  close.end()[-2].duration = 250;

  currentState.operate();
  currentState.setColor();
  LockState::NEUTRAL.operate();

  before = gpio_get(PIN_BUTTON_IN);

  interval.setInterval(
    API_CHECK_INTERVAL * 1000, []() {
      tasks.push_back(Task::API_CHECK);
    },
    API_CHECK_TAG);
  interval.setInterval(
    INTERVAL_LOCK_INTERVAL * 1000, []() {
      if (!interval.hasTag(LOCK_TAG)) tasks.push_back(Task::LOCK_WITHOUT_NOTIFY);
    },
    INTERVAL_LOCK_TAG);

  SerialBT.printf("[setup][%d] start core 1\n", NOW, currentState == LockState::OPEN ? "OPEN" : "CLOSE");
  multicore_launch_core1(waitTask);
  SerialBT.printf("[setup][%d] started core 1\n", NOW, currentState == LockState::OPEN ? "OPEN" : "CLOSE");
}

void loop() {
  bool current = gpio_get(PIN_BUTTON_IN);
  if (!before && current) {
    if (currentState == LockState::CLOSE) {
      currentState = LockState::OPEN;
      tasks.push_back(Task::UNLOCK_API);
      interval.setTimeout(
        MANUAL_OPEN_KEEP_SECONDS * 1000, []() {
          tasks.push_back(Task::LOCK);
        },
        LOCK_TAG);
    } else {
      tasks.push_back(Task::LOCK_API);
      interval.eraseByTag(LOCK_TAG);
      currentState = LockState::CLOSE;
    }

    operate();
  }
  before = current;
  interval.tick();
  sleep_ms(100);
}
